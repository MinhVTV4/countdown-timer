<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bảng Điều Khiển Đếm Ngược Sự Kiện</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        /* Apply Inter font to the body */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Main container styling */
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 2rem 1rem;
            background-color: #f7fafc;
        }

        /* Grid container for countdown cards */
        #multipleCountdownsContainer {
            display: grid;
            gap: 1.5rem;
            width: 100%;
            max-width: 6xl;
            margin-bottom: 2rem;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            justify-content: center;
        }
        /* Placeholder message */
        #noActiveCountdowns {
            grid-column: 1 / -1;
            text-align: center;
            color: #6b7280;
        }

        /* Individual countdown cards */
        .countdown-card {
            background-color: white;
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            position: relative;
        }

        /* Icon and title container */
        .countdown-card .card-title-container {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 0.5rem;
            text-align: center;
            word-break: break-word;
            padding-right: 1.5rem; /* Space for delete button */
        }
        .countdown-card .event-icon {
            font-size: 1.25rem;
            margin-right: 0.5rem;
            flex-shrink: 0;
        }
        .countdown-card .card-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: #1f2937;
        }
        .countdown-card .card-target-date {
             font-size: 0.875rem;
             color: #6b7280;
             margin-bottom: 1rem;
             text-align: center;
         }
         /* Recurring icon indicator */
         .recurring-indicator {
            position: absolute;
            top: 0.5rem;
            right: 2.5rem;
            font-size: 0.75rem;
            color: #6b7280;
            cursor: default;
            z-index: 1;
         }
         /* Delete button on card */
         .card-delete-button {
            position: absolute;
            top: 0.3rem;
            right: 0.3rem;
            background: none;
            border: none;
            font-size: 1.5rem;
            font-weight: bold;
            color: #9ca3af;
            cursor: pointer;
            padding: 0.2rem 0.5rem;
            line-height: 1;
            transition: color 0.2s ease;
            z-index: 2;
         }
         .card-delete-button:hover { color: #ef4444; }

        /* === UPDATED TIMER DISPLAY LAYOUT === */
        /* Layout for time units (Days, Hours) */
        .countdown-card .timer-display {
            display: grid;
            /* Only two columns now */
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem; /* Slightly larger gap */
            width: 100%;
            margin-top: 1rem;
        }
        /* Styling for individual time boxes */
        .countdown-card .time-box {
            background-color: #4A5568;
            padding: 1rem 0.5rem; /* Increased padding */
            border-radius: 0.5rem; /* More rounded */
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-height: 80px; /* Slightly taller */
        }
        /* Styling for the time value (number) */
        .countdown-card .time-value {
            font-weight: 700; /* Bolder */
            line-height: 1.1;
            color: white;
        }
        /* Specific styling for DAYS value - MORE PROMINENT */
        .countdown-card .time-value.days-value {
             font-size: 2.5rem; /* Significantly larger font size ~40px */
             font-weight: 800; /* Extra bold */
             color: #FBBF24; /* Keep amber color */
        }
        /* Specific styling for HOURS value - Smaller */
         .countdown-card .time-value.hours-value {
             font-size: 1.75rem; /* Smaller font size ~28px */
             font-weight: 600; /* Semi-bold */
         }

        /* Styling for the time label ('Ngày', 'Giờ') */
        .countdown-card .time-label {
            font-size: 0.75rem; /* Slightly larger label ~12px */
            color: #A0AEC0;
            margin-top: 0.25rem; /* More space */
            text-transform: uppercase;
            font-weight: 500; /* Medium weight */
        }
        /* === END UPDATED TIMER DISPLAY LAYOUT === */

         /* Styling for the 'finished' state */
        .countdown-card.finished:not(.recurring-active) {
             opacity: 0.7;
        }
        /* Styling for the timer display when finished */
        .countdown-card.finished:not(.recurring-active) .timer-display {
            grid-template-columns: 1fr;
            font-size: 1.25rem;
            font-weight: 600;
            color: #16A34A;
            padding: 1rem 0;
            text-align: center;
            min-height: 80px; /* Match height */
            background-color: #f0fdf4; /* Light green background when finished */
            border-radius: 0.5rem;
        }

        /* Message area styling */
        .message { padding: 0.75rem 1rem; border-radius: 0.375rem; margin: 1rem auto; display: none; text-align: center; width: 100%; max-width: 500px; font-size: 0.875rem; }
        .error-message { background-color: #FEE2E2; color: #B91C1C; border: 1px solid #FCA5A5; }
        .success-message { background-color: #D1FAE5; color: #047857; border: 1px solid #6EE7B7; }
        .info-message { background-color: #DBEAFE; color: #1D4ED8; border: 1px solid #93C5FD; }

        /* Details container */
        #detailsContainer { width: 100%; max-width: 500px; margin-top: 1.5rem; transition: opacity 0.3s ease, max-height 0.5s ease; overflow: hidden; }
        #detailsContainer.hidden { opacity: 0; max-height: 0; margin-top: 0; padding: 0; border: none; }

        /* Saved events list */
        #savedEventsList { width: 100%; background-color: white; border-radius: 0.5rem; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 1rem; max-height: 300px; overflow-y: auto; }
        .saved-event-item { display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem; border-bottom: 1px solid #E2E8F0; cursor: pointer; transition: background-color 0.2s ease; }
        .saved-event-item:last-child { border-bottom: none; }
        .saved-event-item:hover { background-color: #F8FAFC; }
        .saved-event-item.selected { background-color: #EFF6FF; border-left: 4px solid #3B82F6; padding-left: calc(1rem - 4px); }
        .saved-event-item .event-info { flex-grow: 1; overflow: hidden; }
        .saved-event-item .event-title-container { display: flex; align-items: center; margin-bottom: 0.2rem; }
        .saved-event-item .event-icon-list { font-size: 1rem; margin-right: 0.4rem; flex-shrink: 0; width: 1.2em; display: inline-block; text-align: center; }
        .saved-event-item .event-title { font-weight: 500; color: #1F2937; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .saved-event-item .event-date { font-size: 0.875rem; color: #6B7280; }
        .saved-event-item .event-category { font-size: 0.75rem; color: #9CA3AF; margin-top: 0.2rem; font-style: italic; }

        /* Toggle button */
        #toggleDetailsButton { margin-bottom: 1rem; }

        /* Input form */
        #inputFormContainer label { margin-bottom: 0.25rem; display: block; }
        #inputFormContainer .mb-4 { margin-bottom: 1rem; }
        #inputFormContainer textarea { resize: vertical; }
        #inputFormContainer input, #inputFormContainer textarea, #inputFormContainer select { border-color: #D1D5DB; }
        #inputFormContainer input:focus, #inputFormContainer textarea:focus, #inputFormContainer select:focus { border-color: #3B82F6; box-shadow: 0 0 0 1px #3B82F6; outline: none; }
        #inputFormContainer .checkbox-label { display: flex; align-items: center; cursor: pointer; font-size: 0.875rem; color: #374151; }
        #inputFormContainer input[type="checkbox"] { height: 1rem; width: 1rem; margin-right: 0.5rem; border-radius: 0.25rem; border-color: #D1D5DB; color: #3B82F6; cursor: pointer; }
        #inputFormContainer input[type="checkbox"]:focus { ring: 2px; ring-offset: 2px; --tw-ring-offset-color: #fff; --tw-ring-color: #60A5FA; box-shadow: none; border-color: #3B82F6; }

        /* Form buttons */
        .form-button-group { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.75rem; margin-top: 1.5rem; }
        .form-button { padding: 0.6rem 1rem; font-weight: 600; border-radius: 0.375rem; box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05); transition: all 0.2s ease-in-out; text-align: center; cursor: pointer; border: 1px solid transparent; }
        .form-button:focus { outline: none; --tw-ring-offset-width: 2px; --tw-ring-offset-color: #fff; --tw-ring-color: var(--focus-ring-color, #93C5FD); --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color); --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color); box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000); }
        #startButton { background-color: #3B82F6; color: white; --focus-ring-color: #60A5FA; } #startButton:hover { background-color: #2563EB; }
        #saveButton { background-color: #10B981; color: white; --focus-ring-color: #34D399; } #saveButton:hover { background-color: #059669; }
        #newButton { background-color: #F97316; color: white; --focus-ring-color: #FB923C; } #newButton:hover { background-color: #EA580C; }

        /* Responsive adjustments for time display */
        @media (max-width: 420px) {
            .countdown-card .time-value.days-value { font-size: 2rem; } /* Slightly smaller on very small screens */
            .countdown-card .time-value.hours-value { font-size: 1.5rem; }
            .countdown-card .time-label { font-size: 0.7rem; }
            .countdown-card .time-box { min-height: 70px; padding: 0.75rem 0.4rem; }
        }

    </style>
</head>
<body class="bg-gray-100">

    <div class="main-container">
        <h1 class="text-3xl md:text-4xl font-bold text-gray-800 mb-6 text-center">Đếm Ngược Tới Ngày:</h1>

        <div id="multipleCountdownsContainer">
            <p id="noActiveCountdowns">Không có sự kiện nào đang đếm ngược. Hãy thêm một sự kiện mới!</p>
            </div>

        <button id="toggleDetailsButton" class="px-4 py-2 bg-gray-500 text-white text-sm font-semibold rounded-md shadow hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-offset-2 transition duration-150 ease-in-out mb-4">
             Hiện chi tiết quản lý
         </button>

         <div id="messageArea" class="message"></div>

        <div id="detailsContainer" class="hidden">
            <div id="inputFormContainer" class="w-full bg-white p-6 rounded-lg shadow-md mb-6">
                 <h2 id="formTitle" class="text-xl font-semibold text-gray-700 mb-4 text-center">Thêm sự kiện mới</h2>
                 <input type="hidden" id="editingEventId">

                 <div class="mb-4">
                    <label for="eventTitle" class="block text-sm font-medium text-gray-700">Tên sự kiện:</label>
                    <input type="text" id="eventTitle" placeholder="Ví dụ: Sinh nhật của tôi" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                 </div>

                 <div class="mb-4">
                    <label for="eventDate" class="block text-sm font-medium text-gray-700">Ngày và giờ:</label>
                    <input type="datetime-local" id="eventDate" class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                 </div>

                 <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                     <div>
                         <label for="eventIcon" class="block text-sm font-medium text-gray-700">Biểu tượng (Emoji):</label>
                         <input type="text" id="eventIcon" placeholder="🎂 🎉 ✈️ ..." class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                     </div>
                     <div>
                         <label for="eventCategory" class="block text-sm font-medium text-gray-700">Danh mục:</label>
                         <input type="text" id="eventCategory" placeholder="Cá nhân, Công việc..." class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                    </div>
                </div>

                 <div class="mb-4">
                    <label for="eventNotes" class="block text-sm font-medium text-gray-700">Ghi chú:</label>
                    <textarea id="eventNotes" rows="3" placeholder="Thêm mô tả hoặc chi tiết cho sự kiện..." class="w-full p-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"></textarea>
                 </div>

                 <div class="mb-4">
                     <label for="eventRecurring" class="checkbox-label">
                         <input type="checkbox" id="eventRecurring" class="focus:ring-indigo-500 h-4 w-4 text-indigo-600 border-gray-300 rounded">
                         <span>Lặp lại hàng năm?</span>
                     </label>
                 </div>
                 <div class="form-button-group">
                     <button id="startButton" class="form-button">Cập nhật sự kiện</button>
                     <button id="saveButton" class="form-button">Lưu sự kiện mới</button>
                     <button id="newButton" class="form-button">Hủy / Tạo mới</button>
                </div>
            </div>

            <div id="savedEventsContainer" class="w-full">
                 <h2 class="text-xl font-semibold text-gray-700 mb-3 text-center">Quản lý sự kiện đã lưu</h2>
                 <div id="savedEventsList" class="bg-white rounded-lg shadow">
                     <p id="noEventsMessage" class="text-center text-gray-500 py-4">Chưa có sự kiện nào được lưu.</p>
                     </div>
            </div>
        </div>
    </div>

    <script>
        // --- DOM Element References ---
        const multipleCountdownsContainer = document.getElementById('multipleCountdownsContainer');
        const noActiveCountdownsMsg = document.getElementById('noActiveCountdowns');
        const formTitle = document.getElementById('formTitle');
        const editingEventIdInput = document.getElementById('editingEventId');
        const eventTitleInput = document.getElementById('eventTitle');
        const eventDateInput = document.getElementById('eventDate');
        const eventIconInput = document.getElementById('eventIcon');
        const eventCategoryInput = document.getElementById('eventCategory');
        const eventNotesInput = document.getElementById('eventNotes');
        const eventRecurringInput = document.getElementById('eventRecurring');
        const startButton = document.getElementById('startButton');
        const saveButton = document.getElementById('saveButton');
        const newButton = document.getElementById('newButton');
        const messageArea = document.getElementById('messageArea');
        const savedEventsList = document.getElementById('savedEventsList');
        const noEventsMessage = document.getElementById('noEventsMessage');
        const detailsContainer = document.getElementById('detailsContainer');
        const toggleDetailsButton = document.getElementById('toggleDetailsButton');

        // --- State Variables ---
        let countdownIntervals = {};
        let savedEvents = []; // { id, title, date, icon, notes, category, isRecurring, originalDate }
        let detailsVisible = false;

        // --- Utility Functions ---

        /**
         * Generates a default datetime string (tomorrow 9 AM).
         * @returns {string} Formatted datetime string.
         */
        function getDefaultDateTime() {
            const now = new Date();
            now.setDate(now.getDate() + 1);
            now.setHours(9, 0, 0, 0);
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }

        /**
         * Formats a date string for display.
         * @param {string} dateString - Date string.
         * @returns {string} Formatted date or error message.
         */
        function formatDisplayDate(dateString) {
            if (!dateString) return "";
            try {
                const date = new Date(dateString);
                if (isNaN(date.getTime())) return "Ngày không hợp lệ";
                return date.toLocaleString('vi-VN', {
                    year: 'numeric', month: 'numeric', day: 'numeric',
                    hour: '2-digit', minute: '2-digit', hour12: false
                });
            } catch (e) { console.error("Error formatting date:", e); return "Ngày lỗi"; }
        }

        /**
         * Displays a message to the user.
         * @param {string} text - Message text.
         * @param {'error'|'success'|'info'} type - Message type.
         */
        function showMessage(text, type = 'error') {
            messageArea.textContent = text;
            messageArea.className = `message ${type}-message`;
            messageArea.style.display = 'block';
            if (!detailsVisible || !isElementInViewport(messageArea)) {
                messageArea.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
            setTimeout(() => { messageArea.style.display = 'none'; }, 5000);
        }

        /**
         * Checks if an element is in the viewport.
         * @param {HTMLElement} el - The element.
         * @returns {boolean} True if in viewport.
         */
        function isElementInViewport (el) {
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            return ( rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth) );
        }

        /**
         * Toggles the visibility of the details section.
         * @param {boolean} [show] - Force show/hide.
         */
        function toggleDetailsVisibility(show) {
            detailsVisible = (typeof show === 'boolean') ? show : !detailsVisible;
            if (detailsVisible) {
                detailsContainer.classList.remove('hidden');
                requestAnimationFrame(() => { detailsContainer.style.maxHeight = detailsContainer.scrollHeight + "px"; });
                toggleDetailsButton.textContent = "Ẩn chi tiết quản lý";
            } else {
                detailsContainer.style.maxHeight = "0";
                setTimeout(() => { detailsContainer.classList.add('hidden'); }, 300);
                toggleDetailsButton.textContent = "Hiện chi tiết quản lý";
                clearEditSelection();
            }
        }

        // --- Countdown Display Logic ---

        /**
         * Renders or updates a countdown card.
         * @param {object} eventData - The event object.
         */
        function renderOrUpdateCountdownCard(eventData) {
            const existingCard = document.getElementById(`countdown-${eventData.id}`);
            let cardElement = existingCard;
            let timerDisplayElement;

            const targetTime = new Date(eventData.date).getTime();
            if (isNaN(targetTime)) {
                console.warn(`Skipping render: Invalid date for event "${eventData.title}"`);
                if (existingCard) existingCard.remove(); checkIfNoCountdowns(); return;
            }

            const now = new Date().getTime();
            const distance = targetTime - now;
            const isEffectivelyFinished = distance < 0 && !eventData.isRecurring;
            const placeholder = multipleCountdownsContainer.querySelector('#noActiveCountdowns');

            if (!cardElement) {
                cardElement = document.createElement('div');
                cardElement.className = 'countdown-card';
                cardElement.id = `countdown-${eventData.id}`;
                if (placeholder) { multipleCountdownsContainer.insertBefore(cardElement, placeholder); }
                else { multipleCountdownsContainer.appendChild(cardElement); }
            }

            cardElement.classList.toggle('recurring-active', eventData.isRecurring);

            // === UPDATED CARD HTML (Days/Hours only) ===
            cardElement.innerHTML = `
                ${eventData.isRecurring ? '<span class="recurring-indicator" title="Sự kiện lặp lại hàng năm">🔁</span>' : ''}
                <button class="card-delete-button" data-id="${eventData.id}" aria-label="Xóa sự kiện này">&times;</button>
                <div class="card-title-container">
                    ${eventData.icon ? `<span class="event-icon">${eventData.icon}</span>` : ''}
                    <h3 class="card-title">${eventData.title || 'Sự kiện không tên'}</h3>
                </div>
                <p class="card-target-date">Đến: ${formatDisplayDate(eventData.date)}</p>
                <div class="timer-display">
                    ${isEffectivelyFinished ? 'Đã đến giờ!' : `
                        <div class="time-box"><div class="time-value days-value" data-unit="days">0</div><div class="time-label">Ngày</div></div>
                        <div class="time-box"><div class="time-value hours-value" data-unit="hours">0</div><div class="time-label">Giờ</div></div>
                        `}
                </div>
            `;
            // === END UPDATED CARD HTML ===

            timerDisplayElement = cardElement.querySelector('.timer-display');

            // Add event listener for the delete button on the card
            const deleteBtn = cardElement.querySelector('.card-delete-button');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const eventIdStr = e.currentTarget.dataset.id;
                    const eventId = parseInt(eventIdStr);
                    const currentEvent = savedEvents.find(ev => ev.id === eventId);
                    const eventTitle = currentEvent ? (currentEvent.title || 'Không có tiêu đề') : 'sự kiện này';

                    if (window.confirm(`Bạn có chắc chắn muốn xóa sự kiện "${eventTitle}" không?`)) {
                         if (!isNaN(eventId)) { deleteEvent(eventId); }
                         else { console.error("Invalid ID from card delete button:", eventIdStr); showMessage("Lỗi: Không thể xác định sự kiện để xóa.", "error"); }
                    }
                });
            }

            // Handle finished state or start/update timer
            if (isEffectivelyFinished) {
                cardElement.classList.add('finished');
                 if (timerDisplayElement) timerDisplayElement.style.gridTemplateColumns = '1fr';
                stopCountdownInterval(eventData.id);
            } else {
                cardElement.classList.remove('finished');
                 if (timerDisplayElement) {
                      timerDisplayElement.style.gridTemplateColumns = ''; // Reset grid (uses CSS default: 2 columns)
                      updateSingleCountdownTime(eventData.id, timerDisplayElement);
                      startCountdownInterval(eventData.id, timerDisplayElement);
                 }
            }
            checkIfNoCountdowns();
        }

        /**
         * Updates the time display (Days/Hours) for a countdown, handles recurrence.
         * @param {number} eventId - Event ID.
         * @param {HTMLElement} timerDisplayElement - Timer display container.
         */
        function updateSingleCountdownTime(eventId, timerDisplayElement) {
            const eventIndex = savedEvents.findIndex(e => e.id === eventId);
            if (eventIndex === -1) { stopCountdownInterval(eventId); removeCountdownCard(eventId); return; }
            const eventData = savedEvents[eventIndex];

            if (!timerDisplayElement || !timerDisplayElement.closest(`#countdown-${eventId}`)) {
                stopCountdownInterval(eventId); return;
            }

            const targetTime = new Date(eventData.date).getTime();
            const now = new Date().getTime();
            let distance = targetTime - now;

            if (distance < 0) {
                stopCountdownInterval(eventId);
                if (eventData.isRecurring) { handleRecurringEvent(eventData); return; }
                else {
                    const card = timerDisplayElement.closest('.countdown-card');
                    if (card && !card.classList.contains('finished')) {
                        timerDisplayElement.innerHTML = 'Đã đến giờ!';
                        card.classList.add('finished');
                        timerDisplayElement.style.gridTemplateColumns = '1fr';
                    }
                    return;
                }
            }

            // Calculate only days and hours
            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            // Minutes and seconds are no longer needed

            const daysEl = timerDisplayElement.querySelector('[data-unit="days"]');
            const hoursEl = timerDisplayElement.querySelector('[data-unit="hours"]');
            // Remove references to minutes and seconds elements

            // Update only days and hours
            if (daysEl && daysEl.textContent != days) daysEl.textContent = days;
            if (hoursEl && hoursEl.textContent != hours) hoursEl.textContent = hours;
        }

        /**
         * Handles recurring event logic: calculates next date, updates data, re-renders.
         * @param {object} eventData - The finished recurring event.
         */
        function handleRecurringEvent(eventData) {
             console.log(`Handling recurring event: ${eventData.title}`);
             const baseDateStr = eventData.originalDate || eventData.date;
             let nextOccurrence = new Date(baseDateStr);

             if (isNaN(nextOccurrence.getTime())) {
                 console.error(`Invalid base date ("${baseDateStr}") for recurring event: ${eventData.title}`);
                 const eventIndex = savedEvents.findIndex(e => e.id === eventData.id);
                 if (eventIndex > -1) { savedEvents[eventIndex].isRecurring = false; saveEvents(); renderOrUpdateCountdownCard(savedEvents[eventIndex]); }
                 return;
             }

             const now = new Date().getTime();
             let yearsToAdd = 1;
             let safetyCounter = 0;

             while (safetyCounter < 100) {
                let potentialNext = new Date(baseDateStr);
                potentialNext.setFullYear(potentialNext.getFullYear() + yearsToAdd);
                 if (potentialNext.getTime() > now) { nextOccurrence = potentialNext; break; }
                 yearsToAdd++; safetyCounter++;
             }

             if (safetyCounter >= 100) {
                 console.error(`Could not find future occurrence for: ${eventData.title}`);
                 const eventIndex = savedEvents.findIndex(e => e.id === eventData.id);
                  if (eventIndex > -1) { savedEvents[eventIndex].isRecurring = false; saveEvents(); renderOrUpdateCountdownCard(savedEvents[eventIndex]); }
                 return;
             }

             const eventIndex = savedEvents.findIndex(e => e.id === eventData.id);
             if (eventIndex > -1) {
                 const year = nextOccurrence.getFullYear();
                 const month = String(nextOccurrence.getMonth() + 1).padStart(2, '0');
                 const day = String(nextOccurrence.getDate()).padStart(2, '0');
                 const hours = String(nextOccurrence.getHours()).padStart(2, '0');
                 const minutes = String(nextOccurrence.getMinutes()).padStart(2, '0');
                 const nextDateString = `${year}-${month}-${day}T${hours}:${minutes}`;
                 savedEvents[eventIndex].date = nextDateString;
                 console.log(`Event "${eventData.title}" updated to next occurrence: ${nextDateString}`);
                 saveEvents();
                 renderOrUpdateCountdownCard(savedEvents[eventIndex]); // Re-render to restart timer
             } else {
                 console.error(`Could not find event ${eventData.id} to update recurrence.`);
             }
        }

        /**
         * Starts the interval timer for a countdown.
         * @param {number} eventId - The event ID.
         * @param {HTMLElement} timerDisplayElement - The timer display container.
         */
        function startCountdownInterval(eventId, timerDisplayElement) {
            stopCountdownInterval(eventId);
            const card = timerDisplayElement?.closest('.countdown-card');
            if (!card || card.classList.contains('finished')) { return; }
            if (!countdownIntervals[eventId]) {
                 countdownIntervals[eventId] = setInterval(() => {
                     const currentTimerDisplay = document.getElementById(`countdown-${eventId}`)?.querySelector('.timer-display');
                     if (currentTimerDisplay) { updateSingleCountdownTime(eventId, currentTimerDisplay); }
                     else { stopCountdownInterval(eventId); }
                 }, 1000); // Still check every second for hour changes or recurrence
            }
        }

        /**
         * Stops the interval timer for a countdown.
         * @param {number} eventId - The event ID.
         */
        function stopCountdownInterval(eventId) {
            if (countdownIntervals[eventId]) { clearInterval(countdownIntervals[eventId]); delete countdownIntervals[eventId]; }
        }

        /**
         * Removes a countdown card from the display.
         * @param {number} eventId - The event ID.
         */
        function removeCountdownCard(eventId) {
            const card = document.getElementById(`countdown-${eventId}`);
            if (card) { card.remove(); }
            checkIfNoCountdowns();
        }

        /**
         * Checks if any countdown cards are displayed and toggles the placeholder.
         */
        function checkIfNoCountdowns() {
             const placeholder = multipleCountdownsContainer.querySelector('#noActiveCountdowns');
             if (!placeholder) return;
             const activeCards = multipleCountdownsContainer.querySelectorAll('.countdown-card');
             placeholder.style.display = activeCards.length === 0 ? 'block' : 'none';
        }

        /**
         * Renders all active countdowns.
         */
        function renderAllActiveCountdowns() {
            multipleCountdownsContainer.querySelectorAll('.countdown-card').forEach(card => card.remove());
            savedEvents.forEach(event => { renderOrUpdateCountdownCard(event); });
            checkIfNoCountdowns();
        }

        // --- Local Storage & Event Management ---

        /**
         * Loads events from localStorage and ensures data consistency.
         */
        function loadEvents() {
            const storedEvents = localStorage.getItem('countdownEvents');
            let parsedEvents = [];
            try {
                parsedEvents = storedEvents ? JSON.parse(storedEvents) : [];
                 if (!Array.isArray(parsedEvents)) { parsedEvents = []; }
                 savedEvents = parsedEvents.map(event => ({
                     id: event.id, title: event.title || 'Sự kiện không tên', date: event.date,
                     icon: event.icon || '', notes: event.notes || '', category: event.category || '',
                     isRecurring: event.isRecurring || false, originalDate: event.originalDate || null
                 }));
            } catch (e) { console.error("Error parsing saved events:", e); savedEvents = []; showMessage("Lỗi khi tải sự kiện đã lưu.", "error"); }
            renderSavedEventsList();
            renderAllActiveCountdowns();
        }

        /**
         * Saves the current state of events to localStorage.
         */
        function saveEvents() {
             try {
                 const eventsToSave = savedEvents.map(event => ({
                     id: event.id, title: event.title, date: event.date, icon: event.icon,
                     notes: event.notes, category: event.category, isRecurring: event.isRecurring,
                     originalDate: event.originalDate
                 }));
                localStorage.setItem('countdownEvents', JSON.stringify(eventsToSave));
             } catch (e) {
                 console.error("Error saving events:", e);
                 if (e.name === 'QuotaExceededError') { showMessage("Lỗi: Dung lượng lưu trữ đầy.", 'error'); }
                 else { showMessage("Lỗi: Không thể lưu trạng thái.", 'error'); }
             }
        }

        /**
         * Renders the list of saved events in the management section.
         */
        function renderSavedEventsList() {
            savedEventsList.innerHTML = '';
            const placeholder = noEventsMessage.cloneNode(true);
            savedEventsList.appendChild(placeholder);
            if (savedEvents.length === 0) { placeholder.style.display = 'block'; return; }
            placeholder.style.display = 'none';

            const sortedEvents = [...savedEvents].sort((a, b) => {
                const dateA = new Date(a.date).getTime(); const dateB = new Date(b.date).getTime();
                 if (isNaN(dateA)) return 1; if (isNaN(dateB)) return -1; return dateA - dateB;
            });

            sortedEvents.forEach(event => {
                const item = document.createElement('div');
                item.className = 'saved-event-item';
                item.dataset.id = event.id;
                const recurringIndicator = event.isRecurring ? '<span title="Lặp lại hàng năm"> 🔁</span>' : '';
                item.innerHTML = `
                    <div class="event-info">
                        <div class="event-title-container">
                             <span class="event-icon-list">${event.icon || ''}</span>
                             <span class="event-title">${event.title || 'Không có tiêu đề'}${recurringIndicator}</span>
                         </div>
                        <div class="event-date">${formatDisplayDate(event.date)}</div>
                         ${event.category ? `<div class="event-category">Danh mục: ${event.category}</div>` : ''}
                    </div>`; // Delete button removed from here
                item.querySelector('.event-info').addEventListener('click', () => loadEventIntoForm(event.id));
                savedEventsList.appendChild(item);
            });
        }

        /**
         * Deletes an event.
         * @param {number} id - The event ID.
         */
        function deleteEvent(id) {
             console.log(`deleteEvent function called with ID: ${id}`);
             if (typeof id !== 'number' || isNaN(id)) { console.error("deleteEvent invalid ID:", id); showMessage("Lỗi: ID sự kiện không hợp lệ.", "error"); return; }
             const eventIndex = savedEvents.findIndex(e => e.id === id);
             if (eventIndex === -1) { console.warn(`Event ID ${id} not found for deletion.`); return; }
             const eventToDelete = savedEvents[eventIndex];
             const eventTitle = eventToDelete.title || "Không có tiêu đề";
             console.log(`Attempting delete: ID=${id}, Title=${eventTitle}`);
             stopCountdownInterval(id);
             removeCountdownCard(id);
             savedEvents = savedEvents.filter(event => event.id !== id);
             saveEvents();
             renderSavedEventsList();
             if (editingEventIdInput.value == id) { clearEditSelection(); }
             showMessage(`Đã xóa sự kiện "${eventTitle}".`, 'success');
        }

        /**
         * Adds or updates an event based on form data.
         * @param {object} eventData - Placeholder.
         * @param {boolean} isNew - True if adding new.
         * @returns {boolean} True on success.
         */
        function addOrUpdateEvent(eventData = {}, isNew) {
            const id = isNew ? Date.now() : parseInt(editingEventIdInput.value);
            const dateValue = eventDateInput.value;
            const isRecurringValue = eventRecurringInput.checked;
            if (!eventTitleInput.value.trim() || !dateValue) { showMessage("Lỗi: Tên sự kiện và Ngày giờ là bắt buộc.", 'error'); return false; }
            const targetTime = new Date(dateValue).getTime();
             if (isNaN(targetTime)) { showMessage("Lỗi: Ngày giờ không hợp lệ.", 'error'); return false; }
             if (isNew && targetTime < new Date().getTime() && !isRecurringValue) { showMessage("Không thể lưu sự kiện mới trong quá khứ (trừ khi lặp lại).", 'error'); return false; }

             let originalDateValue = null;
             if (isRecurringValue) {
                 if (isNew) { originalDateValue = dateValue; }
                 else { const existingEvent = savedEvents.find(e => e.id == id); originalDateValue = existingEvent?.originalDate || dateValue; }
             }
            const dataToSave = {
                id: id, title: eventTitleInput.value.trim() || "Sự kiện không tên", date: dateValue,
                icon: eventIconInput.value.trim(), notes: eventNotesInput.value.trim(), category: eventCategoryInput.value.trim(),
                isRecurring: isRecurringValue, originalDate: originalDateValue
            };
            if (isNew) { savedEvents.push(dataToSave); }
            else {
                const index = savedEvents.findIndex(e => e.id == dataToSave.id);
                if (index > -1) { savedEvents[index] = dataToSave; }
                else { console.error("Update failed: ID not found", dataToSave.id); showMessage("Lỗi: Không tìm thấy sự kiện.", 'error'); return false; }
            }
            saveEvents(); renderSavedEventsList(); renderOrUpdateCountdownCard(dataToSave); clearEditSelection();
            return true;
        }

        /**
         * Loads event data into the form for editing.
         * @param {number} id - The event ID.
         */
        function loadEventIntoForm(id) {
            const event = savedEvents.find(e => e.id === id);
            if (!event) { showMessage("Không tìm thấy sự kiện.", "error"); return; }
            formTitle.textContent = "Chỉnh sửa sự kiện"; editingEventIdInput.value = event.id; eventTitleInput.value = event.title;
            try { const d = new Date(event.date); if (isNaN(d.getTime())) throw Error(); const off = d.getTimezoneOffset()*60000; eventDateInput.value = new Date(d.getTime()-off).toISOString().slice(0,16); }
            catch (e) { eventDateInput.value = ''; console.error("Date format error:", e); }
            eventIconInput.value = event.icon || ''; eventNotesInput.value = event.notes || ''; eventCategoryInput.value = event.category || '';
            eventRecurringInput.checked = event.isRecurring || false;
            document.querySelectorAll('.saved-event-item').forEach(i => i.classList.remove('selected'));
            const item = document.querySelector(`.saved-event-item[data-id="${id}"]`); if(item) { item.classList.add('selected'); item.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }
            if (!detailsVisible) { toggleDetailsVisibility(true); }
             startButton.style.display = 'block'; saveButton.style.display = 'none'; newButton.textContent = 'Hủy chỉnh sửa'; eventTitleInput.focus();
        }

        /** Clears the form and resets to "Add New" state. */
        function clearEditSelection() {
            formTitle.textContent = "Thêm sự kiện mới"; editingEventIdInput.value = ''; eventTitleInput.value = '';
            eventDateInput.value = getDefaultDateTime(); eventIconInput.value = ''; eventNotesInput.value = ''; eventCategoryInput.value = '';
            eventRecurringInput.checked = false;
            document.querySelectorAll('.saved-event-item').forEach(i => i.classList.remove('selected'));
             startButton.style.display = 'none'; saveButton.style.display = 'block'; newButton.textContent = 'Hủy / Tạo mới';
        }

        // --- Event Listeners Setup ---
        startButton.addEventListener('click', () => { const id = parseInt(editingEventIdInput.value); if (!id||isNaN(id)) { showMessage("Vui lòng chọn sự kiện.",'info'); return; } if(addOrUpdateEvent({},false)) showMessage(`Đã cập nhật "${eventTitleInput.value.trim()||'Không tên'}".`,'success'); });
        saveButton.addEventListener('click', () => { if(addOrUpdateEvent({},true)) showMessage(`Đã lưu "${eventTitleInput.value.trim()||'Không tên'}".`,'success'); });
        newButton.addEventListener('click', () => { const wasEditing=!!editingEventIdInput.value; clearEditSelection(); showMessage(wasEditing?"Đã hủy chỉnh sửa.":"Đã xóa form.",'info'); });
        toggleDetailsButton.addEventListener('click', () => toggleDetailsVisibility());

        // --- Initialization ---
        window.addEventListener('load', () => {
             loadEvents(); clearEditSelection(); startButton.style.display = 'none'; checkIfNoCountdowns();
             savedEvents.forEach(event => { if (event.isRecurring) { const t = new Date(event.date).getTime(); if (!isNaN(t) && t < Date.now()) { console.log(`Initial check: Handling passed recurring: ${event.title}`); handleRecurringEvent(event); } } });
             renderSavedEventsList(); renderAllActiveCountdowns(); // Re-render after initial checks
        });

    </script>

</body>
</html>
